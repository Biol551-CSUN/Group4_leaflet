---
title: "Group 4: Leaflet "
author: "Caroline S."
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    self_contained: false
---
# Introduction

### Leaflet package:
Allows you to create interactive maps using geographical data. You can add markers, lines, and polygons to your map, and customize them with various colors, sizes, and labels. You can also add various types of basemaps, such as satellite imagery or street maps, and control the zoom level and center of your map. Leaflet supports a variety of coordinate systems and projection formats, so you can easily work with data from different sources. Overall, it's a great tool for visualizing geographical data and exploring patterns and trends in your data. 

[Click here](https://rstudio.github.io/leaflet/) to learn more about this package.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      fig.path = "../output/")
```


```{r}
# Libraries ---------------------------------
#install.packages("leaflet.extras")
#install.packages("ggthemes")
library(leaflet) # Leaflet package for creating interactive maps
library(dplyr)   # Dplyr package for data manipulation
library(maps)    # To create the US map
library(RColorBrewer) #To create a color palette
library(leaflet.extras)
library(shiny)
library(ggthemes)
library(purrr)
library(tidyverse)
library(sf)
library(leaflet.extras)
```

# Data
  We used the TidyTuesday "Bird FeederWatch" data for our project.  
  
  More specifically, we focused on the following columns to create an interactive map showing various bird data by state: 

  - latitude  
  - longitude  
  - subnational1_code   
  - Month  
  - species_code  
  - how_many  
  - day1_am  
  - day1_pm  
  - day2_am  
  - day2_pm  

**latitude** / **longitude**: Plot the bird sightings on a map  
**subnational1_code**: Group the sightings by state  
**Month**: Categorize the sightings by season  
**species_code** / **how_many**: Identify and count the number of birds sighted  
**day1_am** / **day1_pm** / **day2_am** / **day2_pm**: Calculate the total number of individuals seen during am or pm time  
  
 [Click here](https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-01-10/readme.md) to access and learn more about this data.

```{r}
# Load BirdFeeder Data ---------------------------------

# Load the bird feeder data from tidy Tuesday 
# Read the data directly from GitHub using readr::read_csv()

feederwatch <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-10/PFW_2021_public.csv')

site_data <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-10/PFW_count_site_data_public_2021.csv')


```



```{r}
# Functions ---------------------------------
#Notes:
        # "how_many" column:	Maximum number of individuals seen at one time during observation period
        # I created a new column named "total_birds" = sum(how_many) aka what is the sum of max number. We might not need this.



# Subset the data to only include relevant columns
feederwatch_sub <- feederwatch %>% select(subnational1_code, species_code, Month, day1_am, day1_pm, day2_am, day2_pm, how_many, latitude, longitude)

# rename the Month column numbers to actual month names
rename_months <- function(month_number) {
  months <- c("January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December")
  return(months[month_number])
}
Month <- rename_months(feederwatch$Month)

# Apply month name change to dataset
feederwatch_sub <- feederwatch_sub %>%
  mutate(month = rename_months(Month))


# Create a function to categorize the birds based on season
categorize_season <- function(month) {
  if (month %in% c("March", "April", "May")) {
    "Spring"
  } else if (month %in% c("June", "July", "August")) {
    "Summer"
  } else if (month %in% c("September", "October", "November")) {
    "Fall"
  } else if (month %in% c("December", "January", "February")) {
    "Winter"
  } else {
    "Year-round"
  }
}


# Categorize the birds based on season
feederwatch_sub <- feederwatch_sub %>%
  mutate(season = map_chr(month, categorize_season))



# Calculate the total of individuals seen during am or pm time
feederwatch_sub <- feederwatch_sub %>%
  mutate(total_am = (day1_am + day2_am),
         total_pm = (day1_pm + day2_pm))


# Group and summarize the data by state, species, and season/month
feederwatch_state <- feederwatch_sub %>%
  group_by(subnational1_code, species_code, season, month) %>%
  reframe(total_birds = sum(how_many),
            total_am = sum(total_am),
            total_pm = sum(total_pm),
            lat = mean(latitude),
            long = mean(longitude)) 



```





```{r}
#CODE IN PROGRESS---------------------------------------------------------------

#map <- leaflet(feederwatch_state) %>% #Create a leaflet map with feederwatch_state data
#  addProviderTiles(tiles) %>% #use some type of tiles for base map
  
# The first function I'm using for our project: addMeasure() ---------------------------

#  addMarkers(...) %>%
   
#  addMeasure(primaryLengthUnit = "meters", secondaryAreaUnit = FALSE) %>%  # Add a measure control to the map. 
 
  #side notes for parameters:
  # setting the length in meters for now
  # I think miles will also work well for this and maybe acres for secondary instead of FALSE?
  #primaryLengthUnit: units used to display length results. 
      #Valid values are "feet", "meters", "miles", and "kilometers".
  #secondaryAreaUnit: units used to display area results. 
      #secondaryAreaUnit is optional. 
      #Valid values are "acres", "hectares", "sqmeters", and "sqmiles".


# The second function I'm using for our project: addSearchOSM() ---------------------------

#  addSearchOSM() %>% # Add search functionality
#  addPolygons(data = us_states, ...) %>%
#  addLegend(...)
  

```



```{r}
#make a dropdown menu to filter by season,month,time,and species_code
#this works but not for rmarkdown knitting so I'm trying to fix this

ui <- fluidPage(
  selectInput("filter_by", "Filter by:", choices = c("season", "month", "time", "species_code")),
  conditionalPanel(
    condition = "input.filter_by == 'season'",
    selectInput("season", "Select Season:", choices = unique(feederwatch_state$season))
  ),
  conditionalPanel(
    condition = "input.filter_by == 'month'",
    selectInput("month", "Select Month:", choices = unique(feederwatch_state$month))
  ),
  conditionalPanel(
    condition = "input.filter_by == 'time'",
    radioButtons("time", "Select Time of Day:", choices = c("am", "pm"))
  ),
  conditionalPanel(
    condition = "input.filter_by == 'species_code'",
    selectInput("species_code", "Select Species:", choices = unique(feederwatch_state$species_code))
  ),
  tableOutput("data")
)

server <- function(input, output, session) {
  output$data <- renderTable({
    data <- feederwatch_state
    if (!is.null(input$filter_by)) {
      if (input$filter_by == "season") {
        data <- filter(data, season == input$season)
      } else if (input$filter_by == "month") {
        data <- filter(data, month == input$month)
      } else if (input$filter_by == "time") {
        if (input$time == "am") {
          data <- data %>% filter(total_am > 0)
        } else if (input$time == "pm") {
          data <- data %>% filter(total_pm > 0)
        }
      } else if (input$filter_by == "species_code") {
        data <- filter(data, species_code == input$species_code)
      }
    }
    data
  })
}

  # Update the dropdown menus based on the filter type selected
  observe({
    if (input$filter_by == "season") {
      updateSelectInput(session, "season", label = "Select Season:",
                        choices = c("All Seasons", unique(feederwatch_state$season)))
      updateSelectInput(session, "month", label = "Select Month:", choices = NULL)
      updateRadioButtons(session, "time", label = "Select Time of Day:", choices = c("am", "pm"))
      updateSelectInput(session, "species_code", label = "Select Species:", choices = NULL)
    } else if (input$filter_by == "month") {
      updateSelectInput(session, "month", label = "Select Month:",
                        choices = c("All Months", unique(feederwatch_state$month)))
      updateSelectInput(session, "season", label = "Select Season:", choices = NULL)
      updateRadioButtons(session, "time", label = "Select Time of Day:", choices = c("am", "pm"))
      updateSelectInput(session, "species_code", label = "Select Species:", choices = NULL)
    } else if (input$filter_by == "time") {
      updateRadioButtons(session, "time", label = "Select Time of Day")
    }
  })

shinyApp(ui, server)

```


```{r}


ui <- fluidPage(
  selectInput("filter_by", "Filter by:", choices = c("season", "month", "time", "species_code")),
  selectInput("time", "Time of Day:", choices = c("am", "pm")),
  leafletOutput("myMap")
)

# Define filter menu after time input
filter_menu <- selectInput("species_code", "Species Code:", choices = unique(feederwatch_state$species_code))


# Define server logic
server <- function(input, output, session) {
  # Create reactive filter
  filtered_data <- reactive({
    data <- feederwatch_state
    if (!is.null(input$filter_by)) {
      if (input$filter_by == "season") {
        data <- filter(data, season == input$season)
      } else if (input$filter_by == "month") {
        data <- filter(data, month == input$month)
      } else if (input$filter_by == "time") {
        if (input$time == "am") {
          data <- data %>% filter(total_am > 0)
        } else if (input$time == "pm") {
          data <- data %>% filter(total_pm > 0)
        }
      } else if (input$filter_by == "species_code") {
        data <- filter(data, species_code == input$species_code)
      }
    }
    data
  })

  output$myMap <- renderLeaflet({
    leaflet(filtered_data()) %>%
      addProviderTiles("CartoDB.Positron") %>%
      setView(-95.7129, 37.0902, zoom = 4) %>%
      addPolygons(data = filtered_data(),
                  fillColor = ~colorQuantile("YlOrRd", total_checklists)(total_checklists),
                  fillOpacity = 0.7,
                  color = "#BDBDC3",
                  weight = 1) %>%
      addLegend(pal = colorQuantile("YlOrRd", total_checklists),
                values = ~total_checklists,
                opacity = 0.7,
                title = "Total Checklists",
                position = "bottomright") %>%
                onRender("function(map, error, options) {
                $('.selectize-control').removeClass('form-control');
                }") %>%
      addControl(filter_menu, position = "topright")
  })
}

# Run the app
shinyApp(ui, server)




```

