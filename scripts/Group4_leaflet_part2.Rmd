---
title: "Untitled"
author: "Caroline S."
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#### Adding Canadian Provinces & ProviderTiles...

This section of the code adds a layer of polygons to the leaflet map, which represent the Canadian provinces. It uses the Canadian provinces' geojson spatial data stored in the "ca_provinces" object to create the polygons. The "addPolygons()" function is used again to add the polygons to the map, with various options for the appearance of the borders and fill color. The "label" argument is used to add province names as labels to the polygons. Additionally, the code adds various basemaps from third-party providers, such as OpenStreetMap and CartoDB, and creates a layer control to allow the user to switch between different basemaps.

```{r Leaflet Map}

province_labels <- ca_provinces$prov_name_en

leaflet(birds_joined) %>% # function adds default OpenStreetMap tile layer (ie. basemap)
  addProviderTiles(providers$OpenStreetMap, group = "OpenStreetMap") %>% # function adds third-party tiles (ie. basemaps)
  addProviderTiles(providers$CartoDB.DarkMatter, group = "CartoDB.DarkMatter") %>% # providers$ argument names third-party basemap
  addProviderTiles(providers$NASAGIBS.ViirsEarthAtNight2012, group = "NASAGIBS.ViirsEarthAtNight2012") %>% # group argument is the name of the group the newly created layers belong to
  addProviderTiles(providers$Esri.WorldImagery, group = "Esri.WorldImagery") %>% 
  addLayersControl(baseGroups = c("OpenStreetMap", # function adds layer controls to hide/show map layers,
                                  # and baseGroups argument creates character vector where each element is the name of a group
                                  "CartoDB.DarkMatter",
                                  "NASAGIBS.ViirsEarthAtNight2012",
                                  "Esri.WorldImagery"),
                   position = "topleft") %>%
  addControl(html = "#TidyTuesday(2023-01-10) - Bird FeederWatch Data", # function adds text box, and html argument displays text
             position = "bottomright")%>%  # position argument moves text box to any corner 
  addMarkers(
  clusterOptions = markerClusterOptions(),
  clusterId = "birdsCluster",
  label = ~sci_name) %>%
  addEasyButton(easyButton(
    states = list(
      easyButtonState(
        stateName="unfrozen-markers",
        icon="ion-toggle",
        title="Freeze Clusters",
        onClick = JS("
          function(btn, map) {
            var clusterManager =
              map.layerManager.getLayer('cluster', 'birdsCluster');
            clusterManager.freezeAtZoom();
            btn.state('frozen-markers');
          }")
      ),
      easyButtonState(
        stateName="frozen-markers",
        icon="ion-toggle-filled",
        title="UnFreeze Clusters",
        onClick = JS("
          function(btn, map) {
            var clusterManager =
              map.layerManager.getLayer('cluster', 'birdsCluster');
            clusterManager.unfreeze();
            btn.state('unfrozen-markers');
          }")
      )
    )
  )) %>% 
  addPolygons(data=us_states,
              color="lavenderblush",
              weight=2,
              opacity=1,
              dashArray = 2.5,
              smoothFactor = 1,
              fillColor = "mediumslateblue",
              fillOpacity = 0.6,
              highlightOptions = highlightOptions(
                weight=3.5,
                color="lavender",
                fillOpacity = .5,
                dashArray = 0,
                bringToFront = TRUE),
              label=state_labels) %>% 
  addPolygons(data=ca_provinces, #use the data from Canadian provinces geojson spatial data
              color="lavenderblush",
              weight=2,
              opacity=1,
              dashArray = 2.5,
              smoothFactor = 1,
              fillColor = "coral", #let's use a different color for Canada...
              fillOpacity = 0.6,
              highlightOptions = highlightOptions(
                weight=3.5,
                color="salmon", #and have a different highlight border color
                fillOpacity = .5,
                dashArray = 0,
                bringToFront = TRUE),
              label=province_labels) #use the Canadian province labels

```

### Caroline's Section

In this section, I've added two more functions to our Leaflet map: addSearchOSM() and addMeasure(). These functions allow users to search for locations on the map and measure distances between points, respectively. The addSearchOSM() function uses the OpenStreetMap Nominatim service to perform a search for a specific location, and addMeasure() creates a tool that allows users to measure distances on the map by clicking on different points.

To add these functions to our map, I simply called them after the previous code, using the pipe operator to continue building on the existing map. Now, users can search for locations and measure distances directly on the map without having to rely on external tools.


#### Functions used: (addProviderTiles, addaddLayersControl, and addControl)

-   More information on how to use the functions above can be found bellow:
    -   [addProviderTiles](https://rstudio.github.io/leaflet/basemaps.html)
    -   [addaddLayersControl](https://bookdown.org/nicohahn/making_maps_with_r5/docs/leaflet.html)
    -   [addControl](https://www.rdocumentation.org/packages/leaflet/versions/2.1.2/topics/addControl)


#### Function descriptions

The addSearchOSM() function allows users to search for specific locations on the map by typing in an address or place name. This function uses the OpenStreetMap Nominatim service to search for the location and then zooms in on the result.

The addMeasure() function adds a measurement tool to the map, which allows users to measure distances and areas on the map. This function adds a control to the map, which can be activated by clicking on the "Measure" button. Once activated, users can click on the map to create points that define the distance or area they want to measure. The measurement is then displayed on the control, and users can either clear the measurement or deactivate the tool by clicking on the "Clear" or "Close" button.

```{r}
# Functions ---------------------------------
#Notes:
        # "how_many" column:	Maximum number of individuals seen at one time during observation period
        # I created a new column named "total_birds" = sum(how_many) aka what is the sum of max number. We might not need this.



# Subset the data to only include relevant columns
feederwatch_sub <- feederwatch %>% select(subnational1_code, species_code, Month, day1_am, day1_pm, day2_am, day2_pm, latitude, longitude)

# rename the Month column numbers to actual month names
rename_months <- function(month_number) {
  months <- c("January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December")
  return(months[month_number])
}

Month <- rename_months(feederwatch$Month)

# Apply month name change to dataset
feederwatch_sub <- feederwatch_sub %>%
  mutate(month = rename_months(Month))


# Create a function to categorize the birds based on season
categorize_season <- function(month) {
  if (month %in% c("March", "April", "May")) {
    "Spring"
  } else if (month %in% c("June", "July", "August")) {
    "Summer"
  } else if (month %in% c("September", "October", "November")) {
    "Fall"
  } else if (month %in% c("December", "January", "February")) {
    "Winter"
  } else {
    "Year-round"
  }
}


# Categorize the birds based on season
feederwatch_sub <- feederwatch_sub %>%
  mutate(season = map_chr(month, categorize_season))



# Calculate the total of individuals seen during am or pm time
feederwatch_sub <- feederwatch_sub %>%
  mutate(total_am = (day1_am + day2_am),
         total_pm = (day1_pm + day2_pm))


# Group and summarize the data by state, species, and season/month
feederwatch_state <- feederwatch_sub %>%
  group_by(subnational1_code, species_code, season, month) %>%
  reframe(total_am = sum(total_am),
            total_pm = sum(total_pm),
            lat = mean(latitude),
            long = mean(longitude)) 


```

#### Using Cindy's code for my subset:

```{r}
Joined_Caroline <- full_join(birds_joined,feederwatch_state) %>% 
  select(loc_id, 
         latitude, 
         longitude, 
         subnational1_code, 
         month, 
         Month, 
         Day, 
         Year, 
         species_code, 
         how_many, 
         sci_name, 
         order, 
         family)

Joined_Caroline$date <- paste(Joined_Caroline$Month, 
                              Joined_Caroline$Day, 
                              Joined_Caroline$Year, 
                              sep = "/")   # the paste function is an R based command that will merge columns together and you can separate the values with a character, like "\"

Joined_filtered <- full_join(Joined_Caroline,feederwatch_state) %>%
  select(loc_id,
         latitude, 
          longitude, 
          subnational1_code, 
          species_code, 
          how_many, 
          sci_name, 
          order, 
          family,
          month,
          date)

print(Joined_filtered)

```

#### Using Jesse's code for final map

```{r}
province_labels <- ca_provinces$prov_name_en

leaflet(Joined_filtered) %>% # function adds default OpenStreetMap tile layer (ie. basemap)
  addProviderTiles(providers$OpenStreetMap, group = "OpenStreetMap") %>% # function adds third-party tiles (ie. basemaps)
  addProviderTiles(providers$CartoDB.DarkMatter, group = "CartoDB.DarkMatter") %>% # providers$ argument names third-party basemap
  addProviderTiles(providers$NASAGIBS.ViirsEarthAtNight2012, group = "NASAGIBS.ViirsEarthAtNight2012") %>% # group argument is the name of the group the newly created layers belong to
  addProviderTiles(providers$Esri.WorldImagery, group = "Esri.WorldImagery") %>% 
  addLayersControl(baseGroups = c("OpenStreetMap", # function adds layer controls to hide/show map layers,
                                  # and baseGroups argument creates character vector where each element is the name of a group
                                  "CartoDB.DarkMatter",
                                  "NASAGIBS.ViirsEarthAtNight2012",
                                  "Esri.WorldImagery"),
                   position = "topleft") %>%
  addControl(html = "#TidyTuesday(2023-01-10) - Bird FeederWatch Data", # function adds text box, and html argument displays text
             position = "bottomright")%>%  # position argument moves text box to any corner 
  addMarkers(
  clusterOptions = markerClusterOptions(),
  clusterId = "birdsCluster",
  label = ~sci_name) %>%
  addEasyButton(easyButton(
    states = list(
      easyButtonState(
        stateName="unfrozen-markers",
        icon="ion-toggle",
        title="Freeze Clusters",
        onClick = JS("
          function(btn, map) {
            var clusterManager =
              map.layerManager.getLayer('cluster', 'birdsCluster');
            clusterManager.freezeAtZoom();
            btn.state('frozen-markers');
          }")
      ),
      easyButtonState(
        stateName="frozen-markers",
        icon="ion-toggle-filled",
        title="UnFreeze Clusters",
        onClick = JS("
          function(btn, map) {
            var clusterManager =
              map.layerManager.getLayer('cluster', 'birdsCluster');
            clusterManager.unfreeze();
            btn.state('unfrozen-markers');
          }")
      )
    )
  )) %>% 
  addPolygons(data=us_states,
              color="lavenderblush",
              weight=2,
              opacity=1,
              dashArray = 2.5,
              smoothFactor = 1,
              fillColor = "mediumslateblue",
              fillOpacity = 0.6,
              highlightOptions = highlightOptions(
                weight=3.5,
                color="lavender",
                fillOpacity = .5,
                dashArray = 0,
                bringToFront = TRUE),
              label=state_labels) %>% 
  addPolygons(data=ca_provinces, #use the data from Canadian provinces geojson spatial data
              color="lavenderblush",
              weight=2,
              opacity=1,
              dashArray = 2.5,
              smoothFactor = 1,
              fillColor = "coral", #let's use a different color for Canada...
              fillOpacity = 0.6,
              highlightOptions = highlightOptions(
                weight=3.5,
                color="salmon", #and have a different highlight border color
                fillOpacity = .5,
                dashArray = 0,
                bringToFront = TRUE),
              label=province_labels) #use the Canadian province labels


```

#### Incorporating the two functions 

In this section, I demonstrate how to incorporate two useful Leaflet functions, addMeasure() and addSearchOSM(), into a Leaflet map created with R. addMeasure() adds a distance measurement tool to the map, which allows users to measure distances between different points on the map. addSearchOSM() adds a search box to the map, which allows users to search for specific addresses or locations on the map. I first convert my data to an sf object and remove any rows with missing longitude or latitude data. 

Then, I create a Leaflet map using my filtered data, add markers to the map, and finally add the addMeasure() and addSearchOSM() functions to the map. The end result is an interactive map that allows users to search for specific locations and measure distances between different points.

```{r}
# Convert to sf object
# Remove rows with missing longitude or latitude
Joined_filtered <- Joined_filtered %>%
  drop_na(longitude, latitude)

Joined_filtered_sf <- Joined_filtered %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

# Create a leaflet map
map <- leaflet(Joined_filtered_sf) %>%
  addTiles() %>%
  addMarkers(data = Joined_filtered)

# Add measure control to the map
map <- map %>% addMeasure()

# Add search box to the map
map <- map %>% addSearchOSM()

# Print the map
map
```

